# å®ç°å¤šç›®å›¾åƒåˆå¹¶å¤„ç†
_Exported on 7/25/2025 at 11:53:14 GMT+8 from Cursor (1.2.4)_

---

**User**

ç›®å‰ä»£ç é€»è¾‘æ˜¯è¯»å–test_binsä¸­çš„binæ–‡ä»¶ä½œä¸ºè¾“å…¥
æœ€ç»ˆè¦å®ç°è®¢é˜…topics /back/left/image_raw ï¼Œ         /back/right/image_raw ï¼Œ/front/left/image_raw           /front/right/image_rawï¼Œ/left/left/image_rawï¼Œ           /left/right/image_raw ï¼Œ/right/left/image_raw ï¼Œ            /right/right/image_raw ï¼Œè¯»å–å¤šç›®å›¾åƒå¹¶åˆå¹¶ä¸º8 * 224 * 400 * 3 ç±»å‹ä¸ºuint8çš„è¾“å…¥


---

**Cursor**

æˆ‘æ¥å¸®æ‚¨å®ç°ä»è¯»å–binæ–‡ä»¶åˆ°è®¢é˜…ROS topicså¹¶åˆå¹¶8ä¸ªæ‘„åƒå¤´å›¾åƒçš„åŠŸèƒ½ã€‚é¦–å…ˆè®©æˆ‘æ¢ç´¢ä¸€ä¸‹é¡¹ç›®ç»“æ„ï¼Œäº†è§£ç°æœ‰çš„ä»£ç æ¶æ„ã€‚

ç°åœ¨æˆ‘æ¥å¸®æ‚¨å®ç°ä»è¯»å–binæ–‡ä»¶æ”¹ä¸ºè®¢é˜…8ä¸ªæ‘„åƒå¤´topicså¹¶åˆå¹¶å›¾åƒçš„åŠŸèƒ½ã€‚åŸºäºä»£ç åˆ†æï¼Œæˆ‘éœ€è¦ï¼š

1. ä¿®æ”¹simplebevçš„CMakeLists.txtæ·»åŠ ROSä¾èµ–
2. åˆ›å»ºå¤šæ‘„åƒå¤´å›¾åƒè®¢é˜…å’Œåˆå¹¶åŠŸèƒ½
3. åˆ›å»ºæ–°çš„ROSèŠ‚ç‚¹mainæ–‡ä»¶

è®©æˆ‘å¼€å§‹å®ç°ï¼š

```plaintext
cmake_minimum_required(VERSION 3.5.1)

project(rknn_simplebev)

set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_FLAGS "-pthread")

# skip 3rd-party lib dependencies
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--allow-shlib-undefined")

if(CMAKE_C_COMPILER MATCHES "aarch64")
  set(LIB_ARCH aarch64)
else()
  set(LIB_ARCH armhf)
endif()

# rknn api
set(RKNN_API_PATH ${CMAKE_SOURCE_DIR}/../runtime//${CMAKE_SYSTEM_NAME}/librknn_api)

if(CMAKE_SYSTEM_NAME STREQUAL "Android")
  set(RKNN_RT_LIB ${RKNN_API_PATH}/${CMAKE_ANDROID_ARCH_ABI}/librknnrt.so)
else()
  set(RKNN_RT_LIB ${RKNN_API_PATH}/${LIB_ARCH}/librknnrt.so)
endif()


include_directories(${RKNN_API_PATH}/include)
include_directories(${CMAKE_SOURCE_DIR}/../3rdparty/)
include_directories(${CMAKE_SOURCE_DIR}/include)

->

cmake_minimum_required(VERSION 3.5.1)

project(rknn_simplebev)

set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_FLAGS "-pthread")

# skip 3rd-party lib dependencies
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,--allow-shlib-undefined")

if(CMAKE_C_COMPILER MATCHES "aarch64")
  set(LIB_ARCH aarch64)
else()
  set(LIB_ARCH armhf)
endif()

# rknn api
set(RKNN_API_PATH ${CMAKE_SOURCE_DIR}/../runtime//${CMAKE_SYSTEM_NAME}/librknn_api)

if(CMAKE_SYSTEM_NAME STREQUAL "Android")
  set(RKNN_RT_LIB ${RKNN_API_PATH}/${CMAKE_ANDROID_ARCH_ABI}/librknnrt.so)
else()
  set(RKNN_RT_LIB ${RKNN_API_PATH}/${LIB_ARCH}/librknnrt.so)
endif()

# ros dependencies
find_package(catkin REQUIRED COMPONENTS
  cv_bridge
  roscpp
  rospy
  sensor_msgs
  std_msgs
  image_transport
)

# opencv
find_package(OpenCV REQUIRED)

include_directories(${RKNN_API_PATH}/include)
include_directories(${CMAKE_SOURCE_DIR}/../3rdparty/)
include_directories(${CMAKE_SOURCE_DIR}/include)
include_directories(${catkin_INCLUDE_DIRS})
```

```plaintext
target_link_libraries(rknn_simplebev
	${RKNN_RT_LIB}
)

->

target_link_libraries(rknn_simplebev
	${RKNN_RT_LIB}
	${catkin_LIBRARIES}
	${OpenCV_LIBS}
)
```

```cpp
#ifndef MULTI_CAMERA_SUBSCRIBER_HPP
#define MULTI_CAMERA_SUBSCRIBER_HPP

#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <cv_bridge/cv_bridge.h>
#include <opencv2/opencv.hpp>
#include <sensor_msgs/Image.h>
#include <message_filters/subscriber.h>
#include <message_filters/time_synchronizer.h>
#include <message_filters/sync_policies/approximate_time.h>
#include <mutex>
#include <vector>
#include <functional>

class MultiCameraSubscriber {
public:
    // å›è°ƒå‡½æ•°ç±»å‹å®šä¹‰
    using ImageCallback = std::function<void(unsigned char*)>;
    
    // æ„é€ å‡½æ•°
    MultiCameraSubscriber(ros::NodeHandle& nh, const ImageCallback& callback);
    
    // ææ„å‡½æ•°
    ~MultiCameraSubscriber();
    
    // å¯åŠ¨è®¢é˜…
    void start();
    
    // åœæ­¢è®¢é˜…
    void stop();
    
    // è·å–åˆå¹¶åçš„å›¾åƒå°ºå¯¸ä¿¡æ¯
    static constexpr int NUM_CAMERAS = 8;
    static constexpr int IMAGE_HEIGHT = 224;
    static constexpr int IMAGE_WIDTH = 400;
    static constexpr int IMAGE_CHANNELS = 3;
    static constexpr int TOTAL_SIZE = NUM_CAMERAS * IMAGE_HEIGHT * IMAGE_WIDTH * IMAGE_CHANNELS;

private:
    // 8ä¸ªæ‘„åƒå¤´åŒæ­¥å›è°ƒå‡½æ•°
    void imageCallback(
        const sensor_msgs::ImageConstPtr& back_left,
        const sensor_msgs::ImageConstPtr& back_right,
        const sensor_msgs::ImageConstPtr& front_left,
        const sensor_msgs::ImageConstPtr& front_right,
        const sensor_msgs::ImageConstPtr& left_left,
        const sensor_msgs::ImageConstPtr& left_right,
        const sensor_msgs::ImageConstPtr& right_left,
        const sensor_msgs::ImageConstPtr& right_right
    );
    
    // å•ä¸ªå›¾åƒé¢„å¤„ç†å‡½æ•°
    cv::Mat preprocessImage(const sensor_msgs::ImageConstPtr& img_msg);
    
    // åˆå¹¶8ä¸ªå›¾åƒ
    void mergeImages(const std::vector<cv::Mat>& images, unsigned char* output_buffer);
    
    ros::NodeHandle& nh_;
    ImageCallback callback_;
    
    // æ¶ˆæ¯è®¢é˜…å™¨
    message_filters::Subscriber<sensor_msgs::Image> back_left_sub_;
    message_filters::Subscriber<sensor_msgs::Image> back_right_sub_;
    message_filters::Subscriber<sensor_msgs::Image> front_left_sub_;
    message_filters::Subscriber<sensor_msgs::Image> front_right_sub_;
    message_filters::Subscriber<sensor_msgs::Image> left_left_sub_;
    message_filters::Subscriber<sensor_msgs::Image> left_right_sub_;
    message_filters::Subscriber<sensor_msgs::Image> right_left_sub_;
    message_filters::Subscriber<sensor_msgs::Image> right_right_sub_;
    
    // æ—¶é—´åŒæ­¥å™¨
    typedef message_filters::sync_policies::ApproximateTime<
        sensor_msgs::Image, sensor_msgs::Image, sensor_msgs::Image, sensor_msgs::Image,
        sensor_msgs::Image, sensor_msgs::Image, sensor_msgs::Image, sensor_msgs::Image
    > SyncPolicy;
    
    std::unique_ptr<message_filters::Synchronizer<SyncPolicy>> sync_;
    
    // è¾“å‡ºç¼“å†²åŒº
    std::unique_ptr<unsigned char[]> output_buffer_;
    
    // äº’æ–¥é”
    std::mutex mutex_;
    
    // è¿è¡ŒçŠ¶æ€
    bool running_;
    
    // ç»Ÿè®¡ä¿¡æ¯
    int frame_count_;
    ros::Time last_fps_time_;
};

#endif // MULTI_CAMERA_SUBSCRIBER_HPP
```

```cpp
#include "multi_camera_subscriber.hpp"
#include <ros/ros.h>

MultiCameraSubscriber::MultiCameraSubscriber(ros::NodeHandle& nh, const ImageCallback& callback)
    : nh_(nh), callback_(callback), running_(false), frame_count_(0),
      back_left_sub_(nh_, "/back/left/image_raw", 1),
      back_right_sub_(nh_, "/back/right/image_raw", 1),
      front_left_sub_(nh_, "/front/left/image_raw", 1),
      front_right_sub_(nh_, "/front/right/image_raw", 1),
      left_left_sub_(nh_, "/left/left/image_raw", 1),
      left_right_sub_(nh_, "/left/right/image_raw", 1),
      right_left_sub_(nh_, "/right/left/image_raw", 1),
      right_right_sub_(nh_, "/right/right/image_raw", 1)
{
    // åˆ†é…è¾“å‡ºç¼“å†²åŒº
    output_buffer_ = std::make_unique<unsigned char[]>(TOTAL_SIZE);
    
    // åˆ›å»ºæ—¶é—´åŒæ­¥å™¨
    sync_ = std::make_unique<message_filters::Synchronizer<SyncPolicy>>(
        SyncPolicy(10), 
        back_left_sub_, back_right_sub_, front_left_sub_, front_right_sub_,
        left_left_sub_, left_right_sub_, right_left_sub_, right_right_sub_
    );
    
    // æ³¨å†ŒåŒæ­¥å›è°ƒ
    sync_->registerCallback(boost::bind(&MultiCameraSubscriber::imageCallback, this, _1, _2, _3, _4, _5, _6, _7, _8));
    
    last_fps_time_ = ros::Time::now();
    
    ROS_INFO("å¤šæ‘„åƒå¤´è®¢é˜…å™¨åˆå§‹åŒ–å®Œæˆ");
    ROS_INFO("è®¢é˜…topics:");
    ROS_INFO("  /back/left/image_raw");
    ROS_INFO("  /back/right/image_raw");
    ROS_INFO("  /front/left/image_raw");
    ROS_INFO("  /front/right/image_raw");
    ROS_INFO("  /left/left/image_raw");
    ROS_INFO("  /left/right/image_raw");
    ROS_INFO("  /right/left/image_raw");
    ROS_INFO("  /right/right/image_raw");
}

MultiCameraSubscriber::~MultiCameraSubscriber() {
    stop();
    ROS_INFO("å¤šæ‘„åƒå¤´è®¢é˜…å™¨é”€æ¯");
}

void MultiCameraSubscriber::start() {
    std::lock_guard<std::mutex> lock(mutex_);
    running_ = true;
    ROS_INFO("å¼€å§‹è®¢é˜…å¤šæ‘„åƒå¤´å›¾åƒ");
}

void MultiCameraSubscriber::stop() {
    std::lock_guard<std::mutex> lock(mutex_);
    running_ = false;
    ROS_INFO("åœæ­¢è®¢é˜…å¤šæ‘„åƒå¤´å›¾åƒ");
}

void MultiCameraSubscriber::imageCallback(
    const sensor_msgs::ImageConstPtr& back_left,
    const sensor_msgs::ImageConstPtr& back_right,
    const sensor_msgs::ImageConstPtr& front_left,
    const sensor_msgs::ImageConstPtr& front_right,
    const sensor_msgs::ImageConstPtr& left_left,
    const sensor_msgs::ImageConstPtr& left_right,
    const sensor_msgs::ImageConstPtr& right_left,
    const sensor_msgs::ImageConstPtr& right_right)
{
    std::lock_guard<std::mutex> lock(mutex_);
    
    if (!running_) {
        return;
    }
    
    try {
        // é¢„å¤„ç†8ä¸ªå›¾åƒ
        std::vector<cv::Mat> images;
        images.reserve(NUM_CAMERAS);
        
        images.push_back(preprocessImage(back_left));
        images.push_back(preprocessImage(back_right));
        images.push_back(preprocessImage(front_left));
        images.push_back(preprocessImage(front_right));
        images.push_back(preprocessImage(left_left));
        images.push_back(preprocessImage(left_right));
        images.push_back(preprocessImage(right_left));
        images.push_back(preprocessImage(right_right));
        
        // åˆå¹¶å›¾åƒ
        mergeImages(images, output_buffer_.get());
        
        // è°ƒç”¨å›è°ƒå‡½æ•°è¿›è¡Œæ¨ç†
        if (callback_) {
            callback_(output_buffer_.get());
        }
        
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        frame_count_++;
        
        // æ¯100å¸§æ‰“å°ä¸€æ¬¡FPS
        if (frame_count_ % 100 == 0) {
            ros::Time current_time = ros::Time::now();
            double elapsed = (current_time - last_fps_time_).toSec();
            if (elapsed > 0) {
                double fps = 100.0 / elapsed;
                ROS_INFO("å¤šæ‘„åƒå¤´å¤„ç†FPS: %.2f", fps);
                last_fps_time_ = current_time;
            }
        }
        
    } catch (const std::exception& e) {
        ROS_ERROR("å›¾åƒå¤„ç†é”™è¯¯: %s", e.what());
    }
}

cv::Mat MultiCameraSubscriber::preprocessImage(const sensor_msgs::ImageConstPtr& img_msg) {
    // è½¬æ¢ROSå›¾åƒä¸ºOpenCVæ ¼å¼
    cv_bridge::CvImageConstPtr cv_ptr;
    try {
        cv_ptr = cv_bridge::toCvShare(img_msg, sensor_msgs::image_encodings::BGR8);
    } catch (cv_bridge::Exception& e) {
        ROS_ERROR("cv_bridgeå¼‚å¸¸: %s", e.what());
        return cv::Mat::zeros(IMAGE_HEIGHT, IMAGE_WIDTH, CV_8UC3);
    }
    
    cv::Mat image = cv_ptr->image;
    cv::Mat resized_image;
    
    // è°ƒæ•´å›¾åƒå°ºå¯¸åˆ° 224x400
    if (image.rows != IMAGE_HEIGHT || image.cols != IMAGE_WIDTH) {
        cv::resize(image, resized_image, cv::Size(IMAGE_WIDTH, IMAGE_HEIGHT), 0, 0, cv::INTER_LINEAR);
    } else {
        resized_image = image.clone();
    }
    
    // ç¡®ä¿å›¾åƒæ ¼å¼ä¸ºBGR8 (3é€šé“)
    if (resized_image.channels() != 3) {
        if (resized_image.channels() == 1) {
            cv::cvtColor(resized_image, resized_image, cv::COLOR_GRAY2BGR);
        } else if (resized_image.channels() == 4) {
            cv::cvtColor(resized_image, resized_image, cv::COLOR_BGRA2BGR);
        }
    }
    
    return resized_image;
}

void MultiCameraSubscriber::mergeImages(const std::vector<cv::Mat>& images, unsigned char* output_buffer) {
    if (images.size() != NUM_CAMERAS) {
        ROS_ERROR("å›¾åƒæ•°é‡ä¸åŒ¹é…ï¼ŒæœŸæœ›%dä¸ªï¼Œå®é™…%zuä¸ª", NUM_CAMERAS, images.size());
        return;
    }
    
    unsigned char* buffer_ptr = output_buffer;
    
    // æŒ‰é¡ºåºå¤åˆ¶æ¯ä¸ªæ‘„åƒå¤´çš„æ•°æ®
    for (int camera_idx = 0; camera_idx < NUM_CAMERAS; ++camera_idx) {
        const cv::Mat& img = images[camera_idx];
        
        if (img.rows != IMAGE_HEIGHT || img.cols != IMAGE_WIDTH || img.channels() != IMAGE_CHANNELS) {
            ROS_ERROR("æ‘„åƒå¤´%då›¾åƒå°ºå¯¸ä¸åŒ¹é…: %dx%dx%dï¼ŒæœŸæœ›: %dx%dx%d", 
                      camera_idx, img.rows, img.cols, img.channels(),
                      IMAGE_HEIGHT, IMAGE_WIDTH, IMAGE_CHANNELS);
            
            // ç”¨é›¶å¡«å……
            memset(buffer_ptr, 0, IMAGE_HEIGHT * IMAGE_WIDTH * IMAGE_CHANNELS);
        } else {
            // å¤åˆ¶å›¾åƒæ•°æ®
            if (img.isContinuous()) {
                memcpy(buffer_ptr, img.data, IMAGE_HEIGHT * IMAGE_WIDTH * IMAGE_CHANNELS);
            } else {
                // å¦‚æœä¸è¿ç»­ï¼ŒæŒ‰è¡Œå¤åˆ¶
                for (int row = 0; row < IMAGE_HEIGHT; ++row) {
                    memcpy(buffer_ptr + row * IMAGE_WIDTH * IMAGE_CHANNELS,
                           img.ptr<unsigned char>(row),
                           IMAGE_WIDTH * IMAGE_CHANNELS);
                }
            }
        }
        
        buffer_ptr += IMAGE_HEIGHT * IMAGE_WIDTH * IMAGE_CHANNELS;
    }
    
    ROS_DEBUG("æˆåŠŸåˆå¹¶%dä¸ªæ‘„åƒå¤´å›¾åƒï¼Œæ€»å¤§å°: %då­—èŠ‚", NUM_CAMERAS, TOTAL_SIZE);
}
```

```plaintext
# ros dependencies
find_package(catkin REQUIRED COMPONENTS
  cv_bridge
  roscpp
  rospy
  sensor_msgs
  std_msgs
  image_transport
)

->

# ros dependencies
find_package(catkin REQUIRED COMPONENTS
  cv_bridge
  roscpp
  rospy
  sensor_msgs
  std_msgs
  image_transport
  message_filters
)
```

```plaintext
add_executable(rknn_simplebev
        src/main.cc
        src/simplebev.cc
)

target_link_libraries(rknn_simplebev
	${RKNN_RT_LIB}
	${catkin_LIBRARIES}
	${OpenCV_LIBS}
)

->

add_executable(rknn_simplebev
        src/main.cc
        src/simplebev.cc
)

add_executable(rknn_simplebev_ros
        src/main_ros.cc
        src/simplebev.cc
        src/multi_camera_subscriber.cpp
)

target_link_libraries(rknn_simplebev
	${RKNN_RT_LIB}
	${catkin_LIBRARIES}
	${OpenCV_LIBS}
)

target_link_libraries(rknn_simplebev_ros
	${RKNN_RT_LIB}
	${catkin_LIBRARIES}
	${OpenCV_LIBS}
)
```

```cpp
#include <ros/ros.h>
#include <signal.h>
#include <stdio.h>
#include <memory>
#include <sys/time.h>
#include "simplebev.hpp"
#include "rknnPool.hpp"
#include "multi_camera_subscriber.hpp"

// å…¨å±€å˜é‡
std::unique_ptr<rknnPool<SimpleBEV, unsigned char*, int>> g_pool;
std::unique_ptr<MultiCameraSubscriber> g_camera_subscriber;
bool g_running = true;

// ä¿¡å·å¤„ç†å‡½æ•°
void signalHandler(int signal) {
    ROS_INFO("æ¥æ”¶åˆ°ä¿¡å· %dï¼Œæ­£åœ¨å…³é—­...", signal);
    g_running = false;
    ros::shutdown();
}

// å›¾åƒå¤„ç†å›è°ƒå‡½æ•°
void imageProcessingCallback(unsigned char* merged_image_data) {
    if (!g_pool || !g_running) {
        return;
    }
    
    // æäº¤å›¾åƒæ•°æ®åˆ°RKNNçº¿ç¨‹æ± è¿›è¡Œæ¨ç†
    if (g_pool->put(merged_image_data) != 0) {
        ROS_WARN("æäº¤å›¾åƒæ•°æ®åˆ°RKNNçº¿ç¨‹æ± å¤±è´¥");
        return;
    }
    
    // å°è¯•è·å–æ¨ç†ç»“æœ
    int result;
    if (g_pool->get(result) == 0) {
        ROS_DEBUG("æ¨ç†å®Œæˆï¼Œç»“æœ: %d", result);
    }
}

int main(int argc, char **argv) {
    // åˆå§‹åŒ–ROSèŠ‚ç‚¹
    ros::init(argc, argv, "rknn_simplebev_multicamera");
    ros::NodeHandle nh;
    
    // è®¾ç½®ä¿¡å·å¤„ç†
    signal(SIGINT, signalHandler);
    signal(SIGTERM, signalHandler);
    
    ROS_INFO("å¯åŠ¨SimpleBEVå¤šæ‘„åƒå¤´ROSèŠ‚ç‚¹");
    
    // æ£€æŸ¥å‘½ä»¤è¡Œå‚æ•°
    if (argc < 5) {
        ROS_ERROR("ç”¨æ³•: %s <encoder_model> <grid_sample_model> <flat_idx_file> <decoder_model>", argv[0]);
        return -1;
    }
    
    // é…ç½®æ¨¡å‹è·¯å¾„
    SimpleBEV::ModelPaths modelPaths{
        argv[1], // encoder
        argv[2], // grid_sample
        argv[4], // decoder
        argv[3]  // flat_idx
    };
    
    ROS_INFO("æ¨¡å‹è·¯å¾„é…ç½®:");
    ROS_INFO("  Encoder: %s", modelPaths.encoder_path.c_str());
    ROS_INFO("  Grid Sample: %s", modelPaths.grid_sample_path.c_str());
    ROS_INFO("  Decoder: %s", modelPaths.decoder_path.c_str());
    ROS_INFO("  Flat Index: %s", modelPaths.flat_idx_path.c_str());
    
    // ä»ROSå‚æ•°æœåŠ¡å™¨è·å–çº¿ç¨‹æ•°
    int threadNum = 1;
    nh.param<int>("thread_num", threadNum, 1);
    ROS_INFO("RKNNçº¿ç¨‹æ± å¤§å°: %d", threadNum);
    
    try {
        // åˆå§‹åŒ–RKNNçº¿ç¨‹æ± 
        ROS_INFO("åˆå§‹åŒ–RKNNçº¿ç¨‹æ± ...");
        g_pool = std::make_unique<rknnPool<SimpleBEV, unsigned char*, int>>(
            modelPaths.encoder_path.c_str(),
            modelPaths.grid_sample_path.c_str(),
            modelPaths.flat_idx_path.c_str(),
            modelPaths.decoder_path.c_str(),
            threadNum
        );
        
        if (g_pool->init() != 0) {
            ROS_ERROR("RKNNçº¿ç¨‹æ± åˆå§‹åŒ–å¤±è´¥!");
            return -1;
        }
        ROS_INFO("RKNNçº¿ç¨‹æ± åˆå§‹åŒ–æˆåŠŸ");
        
        // åˆ›å»ºå¤šæ‘„åƒå¤´è®¢é˜…å™¨
        ROS_INFO("åˆ›å»ºå¤šæ‘„åƒå¤´è®¢é˜…å™¨...");
        g_camera_subscriber = std::make_unique<MultiCameraSubscriber>(
            nh, imageProcessingCallback
        );
        
        // å¯åŠ¨æ‘„åƒå¤´è®¢é˜…
        g_camera_subscriber->start();
        ROS_INFO("å¤šæ‘„åƒå¤´è®¢é˜…å¯åŠ¨æˆåŠŸ");
        
        // ç»Ÿè®¡ä¿¡æ¯
        struct timeval time;
        gettimeofday(&time, nullptr);
        auto startTime = time.tv_sec * 1000 + time.tv_usec / 1000;
        int processed_frames = 0;
        auto beforeTime = startTime;
        
        ROS_INFO("SimpleBEVå¤šæ‘„åƒå¤´èŠ‚ç‚¹å°±ç»ªï¼Œç­‰å¾…å›¾åƒæ•°æ®...");
        ROS_INFO("æœŸæœ›è¾“å…¥æ ¼å¼: 8 x 224 x 400 x 3 = %d bytes", 
                 MultiCameraSubscriber::TOTAL_SIZE);
        
        // ä¸»å¾ªç¯
        ros::Rate loop_rate(100); // 100Hz
        while (ros::ok() && g_running) {
            ros::spinOnce();
            
            // å¤„ç†é˜Ÿåˆ—ä¸­çš„æ¨ç†ç»“æœ
            int result;
            while (g_pool->get(result) == 0) {
                processed_frames++;
                
                // æ¯120å¸§æ‰“å°ä¸€æ¬¡ç»Ÿè®¡ä¿¡æ¯
                if (processed_frames % 120 == 0) {
                    gettimeofday(&time, nullptr);
                    auto currentTime = time.tv_sec * 1000 + time.tv_usec / 1000;
                    double fps = 120.0 / (double)(currentTime - beforeTime) * 1000.0;
                    ROS_INFO("æ¨ç†FPS: %.2f fps", fps);
                    beforeTime = currentTime;
                }
            }
            
            loop_rate.sleep();
        }
        
        // è®¡ç®—æ€»ä½“ç»Ÿè®¡ä¿¡æ¯
        gettimeofday(&time, nullptr);
        auto endTime = time.tv_sec * 1000 + time.tv_usec / 1000;
        if (processed_frames > 0) {
            double total_fps = (double)processed_frames / (double)(endTime - startTime) * 1000.0;
            ROS_INFO("å¹³å‡æ¨ç†FPS: %.2f fps", total_fps);
            ROS_INFO("æ€»å¤„ç†å¸§æ•°: %d", processed_frames);
        }
        
    } catch (const std::exception& e) {
        ROS_ERROR("ç¨‹åºè¿è¡Œå¼‚å¸¸: %s", e.what());
        return -1;
    }
    
    // æ¸…ç†èµ„æº
    ROS_INFO("æ¸…ç†èµ„æº...");
    
    if (g_camera_subscriber) {
        g_camera_subscriber->stop();
        g_camera_subscriber.reset();
    }
    
    if (g_pool) {
        // æ¸…ç©ºçº¿ç¨‹æ± ä¸­å‰©ä½™çš„ä»»åŠ¡
        int remaining_results = 0;
        int result;
        while (g_pool->get(result) == 0) {
            remaining_results++;
        }
        if (remaining_results > 0) {
            ROS_INFO("å¤„ç†å®Œæˆå‰©ä½™çš„%dä¸ªæ¨ç†ç»“æœ", remaining_results);
        }
        g_pool.reset();
    }
    
    ROS_INFO("SimpleBEVå¤šæ‘„åƒå¤´èŠ‚ç‚¹å·²é€€å‡º");
    return 0;
}
```

```plaintext
install(TARGETS rknn_simplebev DESTINATION ./)
install(DIRECTORY model/${TARGET_SOC} DESTINATION ./model)
install(PROGRAMS ${RKNN_RT_LIB} DESTINATION lib)
file(GLOB DATA_FILES "model/*.bin")
install(FILES ${DATA_FILES} DESTINATION ./model/)

->

install(TARGETS rknn_simplebev rknn_simplebev_ros DESTINATION ./)
install(DIRECTORY model/${TARGET_SOC} DESTINATION ./model)
install(PROGRAMS ${RKNN_RT_LIB} DESTINATION lib)
file(GLOB DATA_FILES "model/*.bin")
install(FILES ${DATA_FILES} DESTINATION ./model/)
```

```shellscript
#!/bin/bash

# SimpleBEVå¤šæ‘„åƒå¤´ROSèŠ‚ç‚¹å¯åŠ¨è„šæœ¬
# ç”¨æ³•: ./launch_multicamera.sh [encoder_model] [grid_sample_model] [flat_idx_file] [decoder_model]

set -e

echo "=========================================="
echo "  SimpleBEV å¤šæ‘„åƒå¤´ROSèŠ‚ç‚¹å¯åŠ¨è„šæœ¬"
echo "=========================================="

# æ£€æŸ¥å‚æ•°æ•°é‡
if [ $# -ne 4 ]; then
    echo "é”™è¯¯: éœ€è¦4ä¸ªå‚æ•°"
    echo "ç”¨æ³•: $0 <encoder_model> <grid_sample_model> <flat_idx_file> <decoder_model>"
    echo ""
    echo "ç¤ºä¾‹:"
    echo "  $0 model/encoder.rknn model/grid_sample.rknn model/flat_idx.bin model/decoder.rknn"
    exit 1
fi

# è·å–å‚æ•°
ENCODER_MODEL="$1"
GRID_SAMPLE_MODEL="$2"
FLAT_IDX_FILE="$3"
DECODER_MODEL="$4"

# æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
echo "æ£€æŸ¥æ¨¡å‹æ–‡ä»¶..."
for file in "$ENCODER_MODEL" "$GRID_SAMPLE_MODEL" "$FLAT_IDX_FILE" "$DECODER_MODEL"; do
    if [ ! -f "$file" ]; then
        echo "é”™è¯¯: æ–‡ä»¶ä¸å­˜åœ¨: $file"
        exit 1
    fi
    echo "  âœ“ $file"
done

echo ""
echo "é…ç½®ä¿¡æ¯:"
echo "  Encoder æ¨¡å‹: $ENCODER_MODEL"
echo "  Grid Sample æ¨¡å‹: $GRID_SAMPLE_MODEL"  
echo "  Flat Index æ–‡ä»¶: $FLAT_IDX_FILE"
echo "  Decoder æ¨¡å‹: $DECODER_MODEL"
echo ""

# æ£€æŸ¥ROSç¯å¢ƒ
if [ -z "$ROS_MASTER_URI" ]; then
    echo "è­¦å‘Š: ROSç¯å¢ƒæœªè®¾ç½®ï¼Œå°è¯•source setup.bash..."
    if [ -f "/opt/ros/melodic/setup.bash" ]; then
        source /opt/ros/melodic/setup.bash
    elif [ -f "/opt/ros/noetic/setup.bash" ]; then
        source /opt/ros/noetic/setup.bash
    else
        echo "é”™è¯¯: æ— æ³•æ‰¾åˆ°ROSç¯å¢ƒ"
        exit 1
    fi
fi

echo "ROSç¯å¢ƒ:"
echo "  ROS_MASTER_URI: $ROS_MASTER_URI"
echo "  ROS_DISTRO: ${ROS_DISTRO:-æœªçŸ¥}"
echo ""

# å¯åŠ¨èŠ‚ç‚¹
echo "å¯åŠ¨SimpleBEVå¤šæ‘„åƒå¤´ROSèŠ‚ç‚¹..."
echo "è®¢é˜…çš„topics:"
echo "  /back/left/image_raw"
echo "  /back/right/image_raw"
echo "  /front/left/image_raw"
echo "  /front/right/image_raw"
echo "  /left/left/image_raw"
echo "  /left/right/image_raw"
echo "  /right/left/image_raw"
echo "  /right/right/image_raw"
echo ""
echo "è¾“å…¥æ ¼å¼: 8 x 224 x 400 x 3 = 2,150,400 bytes"
echo ""
echo "æŒ‰ Ctrl+C åœæ­¢èŠ‚ç‚¹"
echo "=========================================="

# è®¾ç½®ROSå‚æ•° (å¯é€‰)
rosparam set /rknn_simplebev_multicamera/thread_num 1

# å¯åŠ¨èŠ‚ç‚¹
exec ./rknn_simplebev_ros "$ENCODER_MODEL" "$GRID_SAMPLE_MODEL" "$FLAT_IDX_FILE" "$DECODER_MODEL"
```

```markdown
# SimpleBEV å¤šæ‘„åƒå¤´ROSé›†æˆ

æœ¬é¡¹ç›®å®ç°äº†SimpleBEVæ¨¡å‹ä¸8ä¸ªæ‘„åƒå¤´çš„ROSé›†æˆï¼Œå°†å¤šç›®å›¾åƒåˆå¹¶ä¸ºç»Ÿä¸€è¾“å…¥è¿›è¡Œæ¨ç†ã€‚

## åŠŸèƒ½ç‰¹æ€§

- **å¤šæ‘„åƒå¤´åŒæ­¥è®¢é˜…**: åŒæ—¶è®¢é˜…8ä¸ªæ‘„åƒå¤´çš„image_raw topics
- **è‡ªåŠ¨å›¾åƒé¢„å¤„ç†**: å°†è¾“å…¥å›¾åƒè°ƒæ•´ä¸º224x400åˆ†è¾¨ç‡
- **å›¾åƒåˆå¹¶**: å°†8ä¸ªæ‘„åƒå¤´å›¾åƒåˆå¹¶ä¸º8Ã—224Ã—400Ã—3æ ¼å¼
- **RKNNæ¨ç†é›†æˆ**: æ— ç¼é›†æˆSimpleBEV RKNNæ¨ç†æµç¨‹
- **å®æ—¶æ€§èƒ½ç›‘æ§**: æä¾›FPSç»Ÿè®¡å’Œæ€§èƒ½ç›‘æ§

## è®¢é˜…çš„Topics

èŠ‚ç‚¹ä¼šè®¢é˜…ä»¥ä¸‹8ä¸ªæ‘„åƒå¤´topicsï¼š

```
/back/left/image_raw       # åå·¦æ‘„åƒå¤´
/back/right/image_raw      # åå³æ‘„åƒå¤´  
/front/left/image_raw      # å‰å·¦æ‘„åƒå¤´
/front/right/image_raw     # å‰å³æ‘„åƒå¤´
/left/left/image_raw       # å·¦å·¦æ‘„åƒå¤´
/left/right/image_raw      # å·¦å³æ‘„åƒå¤´
/right/left/image_raw      # å³å·¦æ‘„åƒå¤´
/right/right/image_raw     # å³å³æ‘„åƒå¤´
```

## æ•°æ®æ ¼å¼

- **è¾“å…¥**: 8ä¸ªç‹¬ç«‹çš„image_rawæ¶ˆæ¯ (sensor_msgs/Image)
- **é¢„å¤„ç†**: æ¯ä¸ªå›¾åƒè°ƒæ•´ä¸º224Ã—400Ã—3 (BGRæ ¼å¼)
- **åˆå¹¶è¾“å‡º**: 8Ã—224Ã—400Ã—3 = 2,150,400å­—èŠ‚çš„uint8æ•°ç»„

## ç¼–è¯‘

```bash
cd rknn_simplebev
mkdir build && cd build
cmake ..
make -j$(nproc)
```

## ä½¿ç”¨æ–¹æ³•

### 1. åŸºæœ¬å¯åŠ¨

```bash
# ç›´æ¥å¯åŠ¨
./rknn_simplebev_ros encoder.rknn grid_sample.rknn flat_idx.bin decoder.rknn

# ä½¿ç”¨å¯åŠ¨è„šæœ¬
chmod +x launch_multicamera.sh
./launch_multicamera.sh model/encoder.rknn model/grid_sample.rknn model/flat_idx.bin model/decoder.rknn
```

### 2. è®¾ç½®ROSå‚æ•°

```bash
# è®¾ç½®RKNNçº¿ç¨‹æ± å¤§å°
rosparam set /rknn_simplebev_multicamera/thread_num 2

# å¯åŠ¨èŠ‚ç‚¹
./rknn_simplebev_ros encoder.rknn grid_sample.rknn flat_idx.bin decoder.rknn
```

### 3. ä½¿ç”¨launchæ–‡ä»¶ (å¯é€‰)

åˆ›å»ºlaunchæ–‡ä»¶ `multicamera_simplebev.launch`:

```xml
<launch>
  <!-- SimpleBEVå¤šæ‘„åƒå¤´èŠ‚ç‚¹ -->
  <node name="rknn_simplebev_multicamera" pkg="rknn_cpp" type="rknn_simplebev_ros" output="screen">
    <param name="thread_num" value="1"/>
    <arg name="encoder_model" value="$(find rknn_cpp)/rknn_simplebev/model/encoder.rknn"/>
    <arg name="grid_sample_model" value="$(find rknn_cpp)/rknn_simplebev/model/grid_sample.rknn"/>
    <arg name="flat_idx_file" value="$(find rknn_cpp)/rknn_simplebev/model/flat_idx.bin"/>
    <arg name="decoder_model" value="$(find rknn_cpp)/rknn_simplebev/model/decoder.rknn"/>
  </node>
</launch>
```

## æ€§èƒ½ç›‘æ§

èŠ‚ç‚¹è¿è¡Œæ—¶ä¼šæ˜¾ç¤ºä»¥ä¸‹ä¿¡æ¯ï¼š

- **å¤šæ‘„åƒå¤´å¤„ç†FPS**: æ¯100å¸§ç»Ÿè®¡ä¸€æ¬¡
- **æ¨ç†FPS**: æ¯120å¸§ç»Ÿè®¡ä¸€æ¬¡  
- **æ€»ä½“å¹³å‡FPS**: ç¨‹åºç»“æŸæ—¶æ˜¾ç¤º

## æ•…éšœæ’é™¤

### 1. Topicsæœªå‘å¸ƒ

```bash
# æ£€æŸ¥å¯ç”¨topics
rostopic list | grep image_raw

# æ£€æŸ¥topicé¢‘ç‡
rostopic hz /back/left/image_raw
```

### 2. å›¾åƒåŒæ­¥é—®é¢˜

å¦‚æœ8ä¸ªæ‘„åƒå¤´æ—¶é—´æˆ³ä¸å®Œå…¨åŒæ­¥ï¼Œå¯ä»¥è°ƒæ•´åŒæ­¥ç­–ç•¥ï¼š

```cpp
// åœ¨MultiCameraSubscriberæ„é€ å‡½æ•°ä¸­è°ƒæ•´
sync_ = std::make_unique<message_filters::Synchronizer<SyncPolicy>>(
    SyncPolicy(20),  // å¢åŠ é˜Ÿåˆ—å¤§å°
    // ... å…¶ä»–å‚æ•°
);
```

### 3. å†…å­˜ä½¿ç”¨è¿‡é«˜

å‡å°‘çº¿ç¨‹æ•°é‡æˆ–è°ƒæ•´ç¼“å†²åŒºå¤§å°ï¼š

```bash
rosparam set /rknn_simplebev_multicamera/thread_num 1
```

### 4. æ¨ç†æ€§èƒ½é—®é¢˜

- æ£€æŸ¥RKNNæ¨¡å‹æ˜¯å¦æ­£ç¡®åŠ è½½
- éªŒè¯è¾“å…¥æ•°æ®æ ¼å¼æ˜¯å¦æ­£ç¡®
- ç›‘æ§ç³»ç»Ÿèµ„æºä½¿ç”¨æƒ…å†µ

## ä»£ç ç»“æ„

```
rknn_simplebev/
â”œâ”€â”€ include/
â”‚   â”œâ”€â”€ multi_camera_subscriber.hpp  # å¤šæ‘„åƒå¤´è®¢é˜…å™¨
â”‚   â””â”€â”€ simplebev.hpp                # SimpleBEVæ¨ç†å¼•æ“
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ multi_camera_subscriber.cpp  # å¤šæ‘„åƒå¤´å®ç°
â”‚   â”œâ”€â”€ main_ros.cc                  # ROSèŠ‚ç‚¹ä¸»ç¨‹åº
â”‚   â””â”€â”€ simplebev.cc                 # SimpleBEVå®ç°
â”œâ”€â”€ launch_multicamera.sh            # å¯åŠ¨è„šæœ¬
â””â”€â”€ README_MULTICAMERA.md            # æœ¬æ–‡æ¡£
```

## æ³¨æ„äº‹é¡¹

1. **æ‘„åƒå¤´åŒæ­¥**: ç¡®ä¿8ä¸ªæ‘„åƒå¤´çš„æ—¶é—´æˆ³å°½å¯èƒ½åŒæ­¥
2. **ç½‘ç»œå¸¦å®½**: 8ä¸ªå›¾åƒæµéœ€è¦è¶³å¤Ÿçš„ç½‘ç»œå¸¦å®½  
3. **è®¡ç®—èµ„æº**: å›¾åƒé¢„å¤„ç†å’Œæ¨ç†éœ€è¦å……è¶³çš„CPU/GPUèµ„æº
4. **å†…å­˜ç®¡ç†**: åˆç†è®¾ç½®çº¿ç¨‹æ± å¤§å°é¿å…å†…å­˜æº¢å‡º

## æŠ€æœ¯æ”¯æŒ

å¦‚é‡é—®é¢˜ï¼Œè¯·æ£€æŸ¥ï¼š

1. ROSç¯å¢ƒæ˜¯å¦æ­£ç¡®é…ç½®
2. æ‰€æœ‰ä¾èµ–åŒ…æ˜¯å¦å·²å®‰è£… (cv_bridge, image_transport, message_filters)
3. RKNNæ¨¡å‹æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”æ ¼å¼æ­£ç¡®
4. æ‘„åƒå¤´topicsæ˜¯å¦æ­£å¸¸å‘å¸ƒ

---

æ›´å¤šä¿¡æ¯è¯·å‚è€ƒé¡¹ç›®ä¸»READMEæ–‡ä»¶ã€‚
```

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
SimpleBEVå¤šæ‘„åƒå¤´æµ‹è¯•å‘å¸ƒå™¨
å‘å¸ƒ8ä¸ªè™šæ‹Ÿæ‘„åƒå¤´æ•°æ®ç”¨äºæµ‹è¯•å¤šæ‘„åƒå¤´è®¢é˜…åŠŸèƒ½
"""

import rospy
import cv2
import numpy as np
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import threading
import time

class TestCameraPublisher:
    def __init__(self):
        rospy.init_node('test_camera_publisher', anonymous=True)
        
        self.bridge = CvBridge()
        
        # 8ä¸ªæ‘„åƒå¤´topicåç§°
        self.camera_topics = [
            '/back/left/image_raw',
            '/back/right/image_raw', 
            '/front/left/image_raw',
            '/front/right/image_raw',
            '/left/left/image_raw',
            '/left/right/image_raw',
            '/right/left/image_raw',
            '/right/right/image_raw'
        ]
        
        # åˆ›å»ºå‘å¸ƒå™¨
        self.publishers = {}
        for topic in self.camera_topics:
            self.publishers[topic] = rospy.Publisher(topic, Image, queue_size=10)
        
        # å›¾åƒå°ºå¯¸
        self.width = 400
        self.height = 224
        
        # å‘å¸ƒé¢‘ç‡
        self.rate = rospy.Rate(10)  # 10Hz
        
        rospy.loginfo("æµ‹è¯•æ‘„åƒå¤´å‘å¸ƒå™¨åˆå§‹åŒ–å®Œæˆ")
        rospy.loginfo("å‘å¸ƒtopics:")
        for topic in self.camera_topics:
            rospy.loginfo(f"  {topic}")
            
    def generate_test_image(self, camera_idx, frame_count):
        """ç”Ÿæˆæµ‹è¯•å›¾åƒ"""
        # åˆ›å»ºå½©è‰²æµ‹è¯•å›¾åƒ
        image = np.zeros((self.height, self.width, 3), dtype=np.uint8)
        
        # ä¸åŒæ‘„åƒå¤´ä½¿ç”¨ä¸åŒé¢œè‰²
        colors = [
            (255, 0, 0),    # è“è‰² - back/left
            (0, 255, 0),    # ç»¿è‰² - back/right
            (0, 0, 255),    # çº¢è‰² - front/left
            (255, 255, 0),  # é’è‰² - front/right
            (255, 0, 255),  # å“çº¢ - left/left
            (0, 255, 255),  # é»„è‰² - left/right
            (128, 128, 128), # ç°è‰² - right/left
            (255, 128, 0)   # æ©™è‰² - right/right
        ]
        
        color = colors[camera_idx % len(colors)]
        image[:, :] = color
        
        # æ·»åŠ æ–‡æœ¬æ ‡è¯†
        camera_names = [
            "BACK-L", "BACK-R", "FRONT-L", "FRONT-R",
            "LEFT-L", "LEFT-R", "RIGHT-L", "RIGHT-R"
        ]
        
        # æ‘„åƒå¤´åç§°
        cv2.putText(image, camera_names[camera_idx], 
                   (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 
                   0.7, (255, 255, 255), 2)
        
        # å¸§è®¡æ•°
        cv2.putText(image, f"Frame: {frame_count}", 
                   (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 
                   0.5, (255, 255, 255), 1)
        
        # æ—¶é—´æˆ³
        cv2.putText(image, f"Time: {time.time():.2f}", 
                   (10, 90), cv2.FONT_HERSHEY_SIMPLEX, 
                   0.4, (255, 255, 255), 1)
        
        # æ·»åŠ ç§»åŠ¨çš„çŸ©å½¢ä½œä¸ºåŠ¨æ€å…ƒç´ 
        rect_x = int((frame_count * 2) % (self.width - 50))
        cv2.rectangle(image, (rect_x, 120), (rect_x + 50, 170), (0, 0, 0), 2)
        
        return image
        
    def publish_images(self):
        """å‘å¸ƒå›¾åƒ"""
        frame_count = 0
        
        rospy.loginfo("å¼€å§‹å‘å¸ƒæµ‹è¯•å›¾åƒ...")
        rospy.loginfo(f"å›¾åƒå°ºå¯¸: {self.width}x{self.height}")
        rospy.loginfo("æŒ‰ Ctrl+C åœæ­¢å‘å¸ƒ")
        
        while not rospy.is_shutdown():
            timestamp = rospy.Time.now()
            
            # ä¸ºæ¯ä¸ªæ‘„åƒå¤´ç”Ÿæˆå¹¶å‘å¸ƒå›¾åƒ
            for i, topic in enumerate(self.camera_topics):
                # ç”Ÿæˆæµ‹è¯•å›¾åƒ
                test_image = self.generate_test_image(i, frame_count)
                
                # è½¬æ¢ä¸ºROSå›¾åƒæ¶ˆæ¯
                try:
                    img_msg = self.bridge.cv2_to_imgmsg(test_image, "bgr8")
                    img_msg.header.stamp = timestamp
                    img_msg.header.frame_id = f"camera_{i}"
                    
                    # å‘å¸ƒå›¾åƒ
                    self.publishers[topic].publish(img_msg)
                    
                except Exception as e:
                    rospy.logerr(f"å‘å¸ƒå›¾åƒå¤±è´¥ {topic}: {e}")
            
            frame_count += 1
            
            # æ¯100å¸§æ‰“å°ä¸€æ¬¡çŠ¶æ€
            if frame_count % 100 == 0:
                rospy.loginfo(f"å·²å‘å¸ƒ {frame_count} å¸§å›¾åƒ")
            
            self.rate.sleep()
            
    def run(self):
        """è¿è¡Œå‘å¸ƒå™¨"""
        try:
            self.publish_images()
        except rospy.ROSInterruptException:
            rospy.loginfo("æµ‹è¯•æ‘„åƒå¤´å‘å¸ƒå™¨å·²åœæ­¢")
        except Exception as e:
            rospy.logerr(f"å‘å¸ƒå™¨è¿è¡Œé”™è¯¯: {e}")

if __name__ == '__main__':
    try:
        publisher = TestCameraPublisher()
        publisher.run()
    except Exception as e:
        print(f"å¯åŠ¨å¤±è´¥: {e}")
```

```markdown
# SimpleBEVå¤šæ‘„åƒå¤´åŠŸèƒ½å¿«é€Ÿå¼€å§‹

## å¿«é€Ÿæµ‹è¯•æ­¥éª¤

### 1. ç¼–è¯‘é¡¹ç›®
```bash
cd rknn_simplebev
mkdir -p build
cd build
cmake ..
make -j$(nproc)
cd ..
```

### 2. å‡†å¤‡æ¨¡å‹æ–‡ä»¶
ç¡®ä¿ä½ æœ‰ä»¥ä¸‹æ¨¡å‹æ–‡ä»¶ï¼š
- `encoder.rknn` - ç¼–ç å™¨æ¨¡å‹
- `grid_sample.rknn` - ç½‘æ ¼é‡‡æ ·æ¨¡å‹  
- `flat_idx.bin` - æ‰å¹³ç´¢å¼•æ–‡ä»¶
- `decoder.rknn` - è§£ç å™¨æ¨¡å‹

### 3. å¯åŠ¨æµ‹è¯•æ‘„åƒå¤´å‘å¸ƒå™¨
åœ¨ç¬¬ä¸€ä¸ªç»ˆç«¯ä¸­è¿è¡Œï¼š
```bash
# å¯åŠ¨ROS master
roscore
```

åœ¨ç¬¬äºŒä¸ªç»ˆç«¯ä¸­è¿è¡Œï¼š
```bash
# å¯åŠ¨æµ‹è¯•æ‘„åƒå¤´å‘å¸ƒå™¨
cd rknn_simplebev
python3 test_camera_publisher.py
```

### 4. å¯åŠ¨SimpleBEVèŠ‚ç‚¹
åœ¨ç¬¬ä¸‰ä¸ªç»ˆç«¯ä¸­è¿è¡Œï¼š
```bash
cd rknn_simplebev/build
../launch_multicamera.sh ../model/encoder.rknn ../model/grid_sample.rknn ../model/flat_idx.bin ../model/decoder.rknn
```

## éªŒè¯è¿è¡Œ

### æ£€æŸ¥topics
```bash
# æŸ¥çœ‹å›¾åƒtopics
rostopic list | grep image_raw

# æ£€æŸ¥å›¾åƒå‘å¸ƒé¢‘ç‡
rostopic hz /back/left/image_raw

# æŸ¥çœ‹å›¾åƒä¿¡æ¯
rostopic info /back/left/image_raw
```

### ç›‘æ§æ€§èƒ½
SimpleBEVèŠ‚ç‚¹ä¼šè¾“å‡ºä»¥ä¸‹ä¿¡æ¯ï¼š
- å¤šæ‘„åƒå¤´å¤„ç†FPS
- æ¨ç†FPS
- æ€»ä½“å¹³å‡FPS

### æ£€æŸ¥æ—¥å¿—
```bash
# æŸ¥çœ‹ROSæ—¥å¿—
roslog list
```

## æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

1. **ç¼–è¯‘é”™è¯¯**
   - æ£€æŸ¥ROSç¯å¢ƒï¼š`echo $ROS_DISTRO`
   - å®‰è£…ä¾èµ–ï¼š`sudo apt install ros-$ROS_DISTRO-cv-bridge ros-$ROS_DISTRO-image-transport`

2. **æ¨¡å‹æ–‡ä»¶ä¸å­˜åœ¨**
   - ç¡®è®¤æ¨¡å‹æ–‡ä»¶è·¯å¾„æ­£ç¡®
   - æ£€æŸ¥æ–‡ä»¶æƒé™

3. **å›¾åƒtopicsæœªå‘å¸ƒ**
   - ç¡®è®¤æµ‹è¯•å‘å¸ƒå™¨æ­£åœ¨è¿è¡Œ
   - æ£€æŸ¥ç½‘ç»œè¿æ¥

4. **æ¨ç†å¤±è´¥**
   - æ£€æŸ¥RKNNè¿è¡Œæ—¶åº“
   - éªŒè¯æ¨¡å‹æ ¼å¼

### è°ƒè¯•å‘½ä»¤
```bash
# æŸ¥çœ‹èŠ‚ç‚¹çŠ¶æ€
rosnode list
rosnode info /rknn_simplebev_multicamera

# æ£€æŸ¥å‚æ•°
rosparam list | grep simplebev
```

## ä¸‹ä¸€æ­¥

æµ‹è¯•æˆåŠŸåï¼Œä½ å¯ä»¥ï¼š
1. æ›¿æ¢æµ‹è¯•å‘å¸ƒå™¨ä¸ºçœŸå®æ‘„åƒå¤´æ•°æ®
2. è°ƒæ•´å›¾åƒé¢„å¤„ç†å‚æ•°
3. ä¼˜åŒ–æ¨ç†æ€§èƒ½
4. é›†æˆåˆ°ä½ çš„åº”ç”¨ä¸­

æ›´å¤šè¯¦ç»†ä¿¡æ¯è¯·å‚è€ƒ `README_MULTICAMERA.md`ã€‚
```

## å®Œæˆï¼âœ…

æˆ‘å·²ç»æˆåŠŸå®ç°äº†ä»è¯»å–binæ–‡ä»¶æ”¹ä¸ºè®¢é˜…8ä¸ªæ‘„åƒå¤´ROS topicså¹¶åˆå¹¶å›¾åƒçš„åŠŸèƒ½ã€‚ä»¥ä¸‹æ˜¯å®Œæˆçš„ä¸»è¦å·¥ä½œï¼š

### ğŸ¯ æ ¸å¿ƒåŠŸèƒ½å®ç°

1. **å¤šæ‘„åƒå¤´è®¢é˜…ç±»** (`MultiCameraSubscriber`)
   - åŒæ—¶è®¢é˜…8ä¸ªæ‘„åƒå¤´topics
   - ä½¿ç”¨message_filterså®ç°æ—¶é—´åŒæ­¥
   - è‡ªåŠ¨å›¾åƒé¢„å¤„ç†ï¼ˆè°ƒæ•´ä¸º224x400x3ï¼‰
   - åˆå¹¶ä¸º8Ã—224Ã—400Ã—3æ ¼å¼çš„uint8æ•°ç»„

2. **ROSèŠ‚ç‚¹ä¸»ç¨‹åº** (`main_ros.cc`)
   - é›†æˆSimpleBEVæ¨ç†æµç¨‹
   - æ€§èƒ½ç›‘æ§å’Œé”™è¯¯å¤„ç†
   - ä¼˜é›…çš„èµ„æºç®¡ç†

3. **æ„å»ºé…ç½®æ›´æ–°**
   - æ·»åŠ ROSä¾èµ–ï¼ˆcv_bridge, image_transport, message_filtersï¼‰
   - æ–°å¢`rknn_simplebev_ros`å¯æ‰§è¡Œæ–‡ä»¶

### ğŸ“‹ è®¢é˜…çš„Topics

- `/back/left/image_raw`
- `/back/right/image_raw`  
- `/front/left/image_raw`
- `/front/right/image_raw`
- `/left/left/image_raw`
- `/left/right/image_raw`
- `/right/left/image_raw`
- `/right/right/image_raw`

### ğŸš€ ä½¿ç”¨æ–¹æ³•

```bash
# ç¼–è¯‘
cd rknn_simplebev && mkdir build && cd build
cmake .. && make -j$(nproc)

# å¯åŠ¨ï¼ˆä½¿ç”¨å¯åŠ¨è„šæœ¬ï¼‰
./launch_multicamera.sh model/encoder.rknn model/grid_sample.rknn model/flat_idx.bin model/decoder.rknn

# æˆ–ç›´æ¥å¯åŠ¨
./rknn_simplebev_ros encoder.rknn grid_sample.rknn flat_idx.bin decoder.rknn
```

### ğŸ§ª æµ‹è¯•å·¥å…·

è¿˜æä¾›äº†ï¼š
- æµ‹è¯•æ‘„åƒå¤´å‘å¸ƒå™¨ (`test_camera_publisher.py`)
- å¿«é€Ÿå¼€å§‹æŒ‡å— (`QUICK_START.md`)
- è¯¦ç»†æ–‡æ¡£ (`README_MULTICAMERA.md`)

### ğŸ“Š æ•°æ®æµæ¶æ„

å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œç³»ç»Ÿå°†8ä¸ªæ‘„åƒå¤´çš„å›¾åƒåŒæ­¥åˆå¹¶ä¸º2,150,400å­—èŠ‚çš„è¿ç»­æ•°ç»„ï¼Œå®Œå…¨ç¬¦åˆSimpleBEVæ¨¡å‹çš„è¾“å…¥è¦æ±‚ã€‚

ç°åœ¨æ‚¨å¯ä»¥ä½¿ç”¨çœŸå®çš„æ‘„åƒå¤´æ•°æ®æ›¿ä»£ä¹‹å‰çš„binæ–‡ä»¶è¾“å…¥ï¼Œå®ç°å®æ—¶çš„å¤šç›®å›¾åƒSimpleBEVæ¨ç†ï¼

```shellscript
# ç¼–è¯‘
cd rknn_simplebev && mkdir build && cd build
cmake .. && make -j$(nproc)

# å¯åŠ¨ï¼ˆä½¿ç”¨å¯åŠ¨è„šæœ¬ï¼‰
./launch_multicamera.sh model/encoder.rknn model/grid_sample.rknn model/flat_idx.bin model/decoder.rknn

# æˆ–ç›´æ¥å¯åŠ¨
./rknn_simplebev_ros encoder.rknn grid_sample.rknn flat_idx.bin decoder.rknn
```

